// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'flexible_option.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FlexibleOptionsTearOff {
  const _$FlexibleOptionsTearOff();

  _FlexibleOptions call(
      {required FlexibleOptionExtraSmall extraSmall,
      required FlexibleOptionSmallFixBody smallFixBody,
      required FlexibleOptionSmallScaleBody smallScaleBody,
      required FlexibleOptionMedium medium,
      required FlexibleOptionLarge large}) {
    return _FlexibleOptions(
      extraSmall: extraSmall,
      smallFixBody: smallFixBody,
      smallScaleBody: smallScaleBody,
      medium: medium,
      large: large,
    );
  }
}

/// @nodoc
const $FlexibleOptions = _$FlexibleOptionsTearOff();

/// @nodoc
mixin _$FlexibleOptions {
  FlexibleOptionExtraSmall get extraSmall => throw _privateConstructorUsedError;
  FlexibleOptionSmallFixBody get smallFixBody =>
      throw _privateConstructorUsedError;
  FlexibleOptionSmallScaleBody get smallScaleBody =>
      throw _privateConstructorUsedError;
  FlexibleOptionMedium get medium => throw _privateConstructorUsedError;
  FlexibleOptionLarge get large => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FlexibleOptionsCopyWith<FlexibleOptions> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FlexibleOptionsCopyWith<$Res> {
  factory $FlexibleOptionsCopyWith(
          FlexibleOptions value, $Res Function(FlexibleOptions) then) =
      _$FlexibleOptionsCopyWithImpl<$Res>;
  $Res call(
      {FlexibleOptionExtraSmall extraSmall,
      FlexibleOptionSmallFixBody smallFixBody,
      FlexibleOptionSmallScaleBody smallScaleBody,
      FlexibleOptionMedium medium,
      FlexibleOptionLarge large});
}

/// @nodoc
class _$FlexibleOptionsCopyWithImpl<$Res>
    implements $FlexibleOptionsCopyWith<$Res> {
  _$FlexibleOptionsCopyWithImpl(this._value, this._then);

  final FlexibleOptions _value;
  // ignore: unused_field
  final $Res Function(FlexibleOptions) _then;

  @override
  $Res call({
    Object? extraSmall = freezed,
    Object? smallFixBody = freezed,
    Object? smallScaleBody = freezed,
    Object? medium = freezed,
    Object? large = freezed,
  }) {
    return _then(_value.copyWith(
      extraSmall: extraSmall == freezed
          ? _value.extraSmall
          : extraSmall // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionExtraSmall,
      smallFixBody: smallFixBody == freezed
          ? _value.smallFixBody
          : smallFixBody // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionSmallFixBody,
      smallScaleBody: smallScaleBody == freezed
          ? _value.smallScaleBody
          : smallScaleBody // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionSmallScaleBody,
      medium: medium == freezed
          ? _value.medium
          : medium // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionMedium,
      large: large == freezed
          ? _value.large
          : large // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionLarge,
    ));
  }
}

/// @nodoc
abstract class _$FlexibleOptionsCopyWith<$Res>
    implements $FlexibleOptionsCopyWith<$Res> {
  factory _$FlexibleOptionsCopyWith(
          _FlexibleOptions value, $Res Function(_FlexibleOptions) then) =
      __$FlexibleOptionsCopyWithImpl<$Res>;
  @override
  $Res call(
      {FlexibleOptionExtraSmall extraSmall,
      FlexibleOptionSmallFixBody smallFixBody,
      FlexibleOptionSmallScaleBody smallScaleBody,
      FlexibleOptionMedium medium,
      FlexibleOptionLarge large});
}

/// @nodoc
class __$FlexibleOptionsCopyWithImpl<$Res>
    extends _$FlexibleOptionsCopyWithImpl<$Res>
    implements _$FlexibleOptionsCopyWith<$Res> {
  __$FlexibleOptionsCopyWithImpl(
      _FlexibleOptions _value, $Res Function(_FlexibleOptions) _then)
      : super(_value, (v) => _then(v as _FlexibleOptions));

  @override
  _FlexibleOptions get _value => super._value as _FlexibleOptions;

  @override
  $Res call({
    Object? extraSmall = freezed,
    Object? smallFixBody = freezed,
    Object? smallScaleBody = freezed,
    Object? medium = freezed,
    Object? large = freezed,
  }) {
    return _then(_FlexibleOptions(
      extraSmall: extraSmall == freezed
          ? _value.extraSmall
          : extraSmall // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionExtraSmall,
      smallFixBody: smallFixBody == freezed
          ? _value.smallFixBody
          : smallFixBody // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionSmallFixBody,
      smallScaleBody: smallScaleBody == freezed
          ? _value.smallScaleBody
          : smallScaleBody // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionSmallScaleBody,
      medium: medium == freezed
          ? _value.medium
          : medium // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionMedium,
      large: large == freezed
          ? _value.large
          : large // ignore: cast_nullable_to_non_nullable
              as FlexibleOptionLarge,
    ));
  }
}

/// @nodoc

class _$_FlexibleOptions
    with DiagnosticableTreeMixin
    implements _FlexibleOptions {
  const _$_FlexibleOptions(
      {required this.extraSmall,
      required this.smallFixBody,
      required this.smallScaleBody,
      required this.medium,
      required this.large});

  @override
  final FlexibleOptionExtraSmall extraSmall;
  @override
  final FlexibleOptionSmallFixBody smallFixBody;
  @override
  final FlexibleOptionSmallScaleBody smallScaleBody;
  @override
  final FlexibleOptionMedium medium;
  @override
  final FlexibleOptionLarge large;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FlexibleOptions(extraSmall: $extraSmall, smallFixBody: $smallFixBody, smallScaleBody: $smallScaleBody, medium: $medium, large: $large)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FlexibleOptions'))
      ..add(DiagnosticsProperty('extraSmall', extraSmall))
      ..add(DiagnosticsProperty('smallFixBody', smallFixBody))
      ..add(DiagnosticsProperty('smallScaleBody', smallScaleBody))
      ..add(DiagnosticsProperty('medium', medium))
      ..add(DiagnosticsProperty('large', large));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FlexibleOptions &&
            const DeepCollectionEquality()
                .equals(other.extraSmall, extraSmall) &&
            const DeepCollectionEquality()
                .equals(other.smallFixBody, smallFixBody) &&
            const DeepCollectionEquality()
                .equals(other.smallScaleBody, smallScaleBody) &&
            const DeepCollectionEquality().equals(other.medium, medium) &&
            const DeepCollectionEquality().equals(other.large, large));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(extraSmall),
      const DeepCollectionEquality().hash(smallFixBody),
      const DeepCollectionEquality().hash(smallScaleBody),
      const DeepCollectionEquality().hash(medium),
      const DeepCollectionEquality().hash(large));

  @JsonKey(ignore: true)
  @override
  _$FlexibleOptionsCopyWith<_FlexibleOptions> get copyWith =>
      __$FlexibleOptionsCopyWithImpl<_FlexibleOptions>(this, _$identity);
}

abstract class _FlexibleOptions implements FlexibleOptions {
  const factory _FlexibleOptions(
      {required FlexibleOptionExtraSmall extraSmall,
      required FlexibleOptionSmallFixBody smallFixBody,
      required FlexibleOptionSmallScaleBody smallScaleBody,
      required FlexibleOptionMedium medium,
      required FlexibleOptionLarge large}) = _$_FlexibleOptions;

  @override
  FlexibleOptionExtraSmall get extraSmall;
  @override
  FlexibleOptionSmallFixBody get smallFixBody;
  @override
  FlexibleOptionSmallScaleBody get smallScaleBody;
  @override
  FlexibleOptionMedium get medium;
  @override
  FlexibleOptionLarge get large;
  @override
  @JsonKey(ignore: true)
  _$FlexibleOptionsCopyWith<_FlexibleOptions> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$FlexibleOptionTearOff {
  const _$FlexibleOptionTearOff();

  FlexibleOptionExtraSmall extraSmall({required FlexibleMode mode}) {
    return FlexibleOptionExtraSmall(
      mode: mode,
    );
  }

  FlexibleOptionSmallFixBody smallFixBody({required FlexibleMode mode}) {
    return FlexibleOptionSmallFixBody(
      mode: mode,
    );
  }

  FlexibleOptionSmallScaleBody smallScaleBody({required FlexibleMode mode}) {
    return FlexibleOptionSmallScaleBody(
      mode: mode,
    );
  }

  FlexibleOptionMedium medium({required FlexibleMode mode}) {
    return FlexibleOptionMedium(
      mode: mode,
    );
  }

  FlexibleOptionLarge large({required FlexibleMode mode}) {
    return FlexibleOptionLarge(
      mode: mode,
    );
  }
}

/// @nodoc
const $FlexibleOption = _$FlexibleOptionTearOff();

/// @nodoc
mixin _$FlexibleOption {
  FlexibleMode get mode => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FlexibleMode mode) extraSmall,
    required TResult Function(FlexibleMode mode) smallFixBody,
    required TResult Function(FlexibleMode mode) smallScaleBody,
    required TResult Function(FlexibleMode mode) medium,
    required TResult Function(FlexibleMode mode) large,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FlexibleOptionExtraSmall value) extraSmall,
    required TResult Function(FlexibleOptionSmallFixBody value) smallFixBody,
    required TResult Function(FlexibleOptionSmallScaleBody value)
        smallScaleBody,
    required TResult Function(FlexibleOptionMedium value) medium,
    required TResult Function(FlexibleOptionLarge value) large,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FlexibleOptionCopyWith<FlexibleOption> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FlexibleOptionCopyWith<$Res> {
  factory $FlexibleOptionCopyWith(
          FlexibleOption value, $Res Function(FlexibleOption) then) =
      _$FlexibleOptionCopyWithImpl<$Res>;
  $Res call({FlexibleMode mode});
}

/// @nodoc
class _$FlexibleOptionCopyWithImpl<$Res>
    implements $FlexibleOptionCopyWith<$Res> {
  _$FlexibleOptionCopyWithImpl(this._value, this._then);

  final FlexibleOption _value;
  // ignore: unused_field
  final $Res Function(FlexibleOption) _then;

  @override
  $Res call({
    Object? mode = freezed,
  }) {
    return _then(_value.copyWith(
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as FlexibleMode,
    ));
  }
}

/// @nodoc
abstract class $FlexibleOptionExtraSmallCopyWith<$Res>
    implements $FlexibleOptionCopyWith<$Res> {
  factory $FlexibleOptionExtraSmallCopyWith(FlexibleOptionExtraSmall value,
          $Res Function(FlexibleOptionExtraSmall) then) =
      _$FlexibleOptionExtraSmallCopyWithImpl<$Res>;
  @override
  $Res call({FlexibleMode mode});
}

/// @nodoc
class _$FlexibleOptionExtraSmallCopyWithImpl<$Res>
    extends _$FlexibleOptionCopyWithImpl<$Res>
    implements $FlexibleOptionExtraSmallCopyWith<$Res> {
  _$FlexibleOptionExtraSmallCopyWithImpl(FlexibleOptionExtraSmall _value,
      $Res Function(FlexibleOptionExtraSmall) _then)
      : super(_value, (v) => _then(v as FlexibleOptionExtraSmall));

  @override
  FlexibleOptionExtraSmall get _value =>
      super._value as FlexibleOptionExtraSmall;

  @override
  $Res call({
    Object? mode = freezed,
  }) {
    return _then(FlexibleOptionExtraSmall(
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as FlexibleMode,
    ));
  }
}

/// @nodoc

class _$FlexibleOptionExtraSmall
    with DiagnosticableTreeMixin
    implements FlexibleOptionExtraSmall {
  const _$FlexibleOptionExtraSmall({required this.mode});

  @override
  final FlexibleMode mode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FlexibleOption.extraSmall(mode: $mode)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FlexibleOption.extraSmall'))
      ..add(DiagnosticsProperty('mode', mode));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FlexibleOptionExtraSmall &&
            const DeepCollectionEquality().equals(other.mode, mode));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(mode));

  @JsonKey(ignore: true)
  @override
  $FlexibleOptionExtraSmallCopyWith<FlexibleOptionExtraSmall> get copyWith =>
      _$FlexibleOptionExtraSmallCopyWithImpl<FlexibleOptionExtraSmall>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FlexibleMode mode) extraSmall,
    required TResult Function(FlexibleMode mode) smallFixBody,
    required TResult Function(FlexibleMode mode) smallScaleBody,
    required TResult Function(FlexibleMode mode) medium,
    required TResult Function(FlexibleMode mode) large,
  }) {
    return extraSmall(mode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
  }) {
    return extraSmall?.call(mode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
    required TResult orElse(),
  }) {
    if (extraSmall != null) {
      return extraSmall(mode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FlexibleOptionExtraSmall value) extraSmall,
    required TResult Function(FlexibleOptionSmallFixBody value) smallFixBody,
    required TResult Function(FlexibleOptionSmallScaleBody value)
        smallScaleBody,
    required TResult Function(FlexibleOptionMedium value) medium,
    required TResult Function(FlexibleOptionLarge value) large,
  }) {
    return extraSmall(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
  }) {
    return extraSmall?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
    required TResult orElse(),
  }) {
    if (extraSmall != null) {
      return extraSmall(this);
    }
    return orElse();
  }
}

abstract class FlexibleOptionExtraSmall implements FlexibleOption {
  const factory FlexibleOptionExtraSmall({required FlexibleMode mode}) =
      _$FlexibleOptionExtraSmall;

  @override
  FlexibleMode get mode;
  @override
  @JsonKey(ignore: true)
  $FlexibleOptionExtraSmallCopyWith<FlexibleOptionExtraSmall> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FlexibleOptionSmallFixBodyCopyWith<$Res>
    implements $FlexibleOptionCopyWith<$Res> {
  factory $FlexibleOptionSmallFixBodyCopyWith(FlexibleOptionSmallFixBody value,
          $Res Function(FlexibleOptionSmallFixBody) then) =
      _$FlexibleOptionSmallFixBodyCopyWithImpl<$Res>;
  @override
  $Res call({FlexibleMode mode});
}

/// @nodoc
class _$FlexibleOptionSmallFixBodyCopyWithImpl<$Res>
    extends _$FlexibleOptionCopyWithImpl<$Res>
    implements $FlexibleOptionSmallFixBodyCopyWith<$Res> {
  _$FlexibleOptionSmallFixBodyCopyWithImpl(FlexibleOptionSmallFixBody _value,
      $Res Function(FlexibleOptionSmallFixBody) _then)
      : super(_value, (v) => _then(v as FlexibleOptionSmallFixBody));

  @override
  FlexibleOptionSmallFixBody get _value =>
      super._value as FlexibleOptionSmallFixBody;

  @override
  $Res call({
    Object? mode = freezed,
  }) {
    return _then(FlexibleOptionSmallFixBody(
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as FlexibleMode,
    ));
  }
}

/// @nodoc

class _$FlexibleOptionSmallFixBody
    with DiagnosticableTreeMixin
    implements FlexibleOptionSmallFixBody {
  const _$FlexibleOptionSmallFixBody({required this.mode});

  @override
  final FlexibleMode mode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FlexibleOption.smallFixBody(mode: $mode)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FlexibleOption.smallFixBody'))
      ..add(DiagnosticsProperty('mode', mode));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FlexibleOptionSmallFixBody &&
            const DeepCollectionEquality().equals(other.mode, mode));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(mode));

  @JsonKey(ignore: true)
  @override
  $FlexibleOptionSmallFixBodyCopyWith<FlexibleOptionSmallFixBody>
      get copyWith =>
          _$FlexibleOptionSmallFixBodyCopyWithImpl<FlexibleOptionSmallFixBody>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FlexibleMode mode) extraSmall,
    required TResult Function(FlexibleMode mode) smallFixBody,
    required TResult Function(FlexibleMode mode) smallScaleBody,
    required TResult Function(FlexibleMode mode) medium,
    required TResult Function(FlexibleMode mode) large,
  }) {
    return smallFixBody(mode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
  }) {
    return smallFixBody?.call(mode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
    required TResult orElse(),
  }) {
    if (smallFixBody != null) {
      return smallFixBody(mode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FlexibleOptionExtraSmall value) extraSmall,
    required TResult Function(FlexibleOptionSmallFixBody value) smallFixBody,
    required TResult Function(FlexibleOptionSmallScaleBody value)
        smallScaleBody,
    required TResult Function(FlexibleOptionMedium value) medium,
    required TResult Function(FlexibleOptionLarge value) large,
  }) {
    return smallFixBody(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
  }) {
    return smallFixBody?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
    required TResult orElse(),
  }) {
    if (smallFixBody != null) {
      return smallFixBody(this);
    }
    return orElse();
  }
}

abstract class FlexibleOptionSmallFixBody implements FlexibleOption {
  const factory FlexibleOptionSmallFixBody({required FlexibleMode mode}) =
      _$FlexibleOptionSmallFixBody;

  @override
  FlexibleMode get mode;
  @override
  @JsonKey(ignore: true)
  $FlexibleOptionSmallFixBodyCopyWith<FlexibleOptionSmallFixBody>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FlexibleOptionSmallScaleBodyCopyWith<$Res>
    implements $FlexibleOptionCopyWith<$Res> {
  factory $FlexibleOptionSmallScaleBodyCopyWith(
          FlexibleOptionSmallScaleBody value,
          $Res Function(FlexibleOptionSmallScaleBody) then) =
      _$FlexibleOptionSmallScaleBodyCopyWithImpl<$Res>;
  @override
  $Res call({FlexibleMode mode});
}

/// @nodoc
class _$FlexibleOptionSmallScaleBodyCopyWithImpl<$Res>
    extends _$FlexibleOptionCopyWithImpl<$Res>
    implements $FlexibleOptionSmallScaleBodyCopyWith<$Res> {
  _$FlexibleOptionSmallScaleBodyCopyWithImpl(
      FlexibleOptionSmallScaleBody _value,
      $Res Function(FlexibleOptionSmallScaleBody) _then)
      : super(_value, (v) => _then(v as FlexibleOptionSmallScaleBody));

  @override
  FlexibleOptionSmallScaleBody get _value =>
      super._value as FlexibleOptionSmallScaleBody;

  @override
  $Res call({
    Object? mode = freezed,
  }) {
    return _then(FlexibleOptionSmallScaleBody(
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as FlexibleMode,
    ));
  }
}

/// @nodoc

class _$FlexibleOptionSmallScaleBody
    with DiagnosticableTreeMixin
    implements FlexibleOptionSmallScaleBody {
  const _$FlexibleOptionSmallScaleBody({required this.mode});

  @override
  final FlexibleMode mode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FlexibleOption.smallScaleBody(mode: $mode)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FlexibleOption.smallScaleBody'))
      ..add(DiagnosticsProperty('mode', mode));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FlexibleOptionSmallScaleBody &&
            const DeepCollectionEquality().equals(other.mode, mode));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(mode));

  @JsonKey(ignore: true)
  @override
  $FlexibleOptionSmallScaleBodyCopyWith<FlexibleOptionSmallScaleBody>
      get copyWith => _$FlexibleOptionSmallScaleBodyCopyWithImpl<
          FlexibleOptionSmallScaleBody>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FlexibleMode mode) extraSmall,
    required TResult Function(FlexibleMode mode) smallFixBody,
    required TResult Function(FlexibleMode mode) smallScaleBody,
    required TResult Function(FlexibleMode mode) medium,
    required TResult Function(FlexibleMode mode) large,
  }) {
    return smallScaleBody(mode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
  }) {
    return smallScaleBody?.call(mode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
    required TResult orElse(),
  }) {
    if (smallScaleBody != null) {
      return smallScaleBody(mode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FlexibleOptionExtraSmall value) extraSmall,
    required TResult Function(FlexibleOptionSmallFixBody value) smallFixBody,
    required TResult Function(FlexibleOptionSmallScaleBody value)
        smallScaleBody,
    required TResult Function(FlexibleOptionMedium value) medium,
    required TResult Function(FlexibleOptionLarge value) large,
  }) {
    return smallScaleBody(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
  }) {
    return smallScaleBody?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
    required TResult orElse(),
  }) {
    if (smallScaleBody != null) {
      return smallScaleBody(this);
    }
    return orElse();
  }
}

abstract class FlexibleOptionSmallScaleBody implements FlexibleOption {
  const factory FlexibleOptionSmallScaleBody({required FlexibleMode mode}) =
      _$FlexibleOptionSmallScaleBody;

  @override
  FlexibleMode get mode;
  @override
  @JsonKey(ignore: true)
  $FlexibleOptionSmallScaleBodyCopyWith<FlexibleOptionSmallScaleBody>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FlexibleOptionMediumCopyWith<$Res>
    implements $FlexibleOptionCopyWith<$Res> {
  factory $FlexibleOptionMediumCopyWith(FlexibleOptionMedium value,
          $Res Function(FlexibleOptionMedium) then) =
      _$FlexibleOptionMediumCopyWithImpl<$Res>;
  @override
  $Res call({FlexibleMode mode});
}

/// @nodoc
class _$FlexibleOptionMediumCopyWithImpl<$Res>
    extends _$FlexibleOptionCopyWithImpl<$Res>
    implements $FlexibleOptionMediumCopyWith<$Res> {
  _$FlexibleOptionMediumCopyWithImpl(
      FlexibleOptionMedium _value, $Res Function(FlexibleOptionMedium) _then)
      : super(_value, (v) => _then(v as FlexibleOptionMedium));

  @override
  FlexibleOptionMedium get _value => super._value as FlexibleOptionMedium;

  @override
  $Res call({
    Object? mode = freezed,
  }) {
    return _then(FlexibleOptionMedium(
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as FlexibleMode,
    ));
  }
}

/// @nodoc

class _$FlexibleOptionMedium
    with DiagnosticableTreeMixin
    implements FlexibleOptionMedium {
  const _$FlexibleOptionMedium({required this.mode});

  @override
  final FlexibleMode mode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FlexibleOption.medium(mode: $mode)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FlexibleOption.medium'))
      ..add(DiagnosticsProperty('mode', mode));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FlexibleOptionMedium &&
            const DeepCollectionEquality().equals(other.mode, mode));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(mode));

  @JsonKey(ignore: true)
  @override
  $FlexibleOptionMediumCopyWith<FlexibleOptionMedium> get copyWith =>
      _$FlexibleOptionMediumCopyWithImpl<FlexibleOptionMedium>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FlexibleMode mode) extraSmall,
    required TResult Function(FlexibleMode mode) smallFixBody,
    required TResult Function(FlexibleMode mode) smallScaleBody,
    required TResult Function(FlexibleMode mode) medium,
    required TResult Function(FlexibleMode mode) large,
  }) {
    return medium(mode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
  }) {
    return medium?.call(mode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
    required TResult orElse(),
  }) {
    if (medium != null) {
      return medium(mode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FlexibleOptionExtraSmall value) extraSmall,
    required TResult Function(FlexibleOptionSmallFixBody value) smallFixBody,
    required TResult Function(FlexibleOptionSmallScaleBody value)
        smallScaleBody,
    required TResult Function(FlexibleOptionMedium value) medium,
    required TResult Function(FlexibleOptionLarge value) large,
  }) {
    return medium(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
  }) {
    return medium?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
    required TResult orElse(),
  }) {
    if (medium != null) {
      return medium(this);
    }
    return orElse();
  }
}

abstract class FlexibleOptionMedium implements FlexibleOption {
  const factory FlexibleOptionMedium({required FlexibleMode mode}) =
      _$FlexibleOptionMedium;

  @override
  FlexibleMode get mode;
  @override
  @JsonKey(ignore: true)
  $FlexibleOptionMediumCopyWith<FlexibleOptionMedium> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FlexibleOptionLargeCopyWith<$Res>
    implements $FlexibleOptionCopyWith<$Res> {
  factory $FlexibleOptionLargeCopyWith(
          FlexibleOptionLarge value, $Res Function(FlexibleOptionLarge) then) =
      _$FlexibleOptionLargeCopyWithImpl<$Res>;
  @override
  $Res call({FlexibleMode mode});
}

/// @nodoc
class _$FlexibleOptionLargeCopyWithImpl<$Res>
    extends _$FlexibleOptionCopyWithImpl<$Res>
    implements $FlexibleOptionLargeCopyWith<$Res> {
  _$FlexibleOptionLargeCopyWithImpl(
      FlexibleOptionLarge _value, $Res Function(FlexibleOptionLarge) _then)
      : super(_value, (v) => _then(v as FlexibleOptionLarge));

  @override
  FlexibleOptionLarge get _value => super._value as FlexibleOptionLarge;

  @override
  $Res call({
    Object? mode = freezed,
  }) {
    return _then(FlexibleOptionLarge(
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as FlexibleMode,
    ));
  }
}

/// @nodoc

class _$FlexibleOptionLarge
    with DiagnosticableTreeMixin
    implements FlexibleOptionLarge {
  const _$FlexibleOptionLarge({required this.mode});

  @override
  final FlexibleMode mode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FlexibleOption.large(mode: $mode)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FlexibleOption.large'))
      ..add(DiagnosticsProperty('mode', mode));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FlexibleOptionLarge &&
            const DeepCollectionEquality().equals(other.mode, mode));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(mode));

  @JsonKey(ignore: true)
  @override
  $FlexibleOptionLargeCopyWith<FlexibleOptionLarge> get copyWith =>
      _$FlexibleOptionLargeCopyWithImpl<FlexibleOptionLarge>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FlexibleMode mode) extraSmall,
    required TResult Function(FlexibleMode mode) smallFixBody,
    required TResult Function(FlexibleMode mode) smallScaleBody,
    required TResult Function(FlexibleMode mode) medium,
    required TResult Function(FlexibleMode mode) large,
  }) {
    return large(mode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
  }) {
    return large?.call(mode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FlexibleMode mode)? extraSmall,
    TResult Function(FlexibleMode mode)? smallFixBody,
    TResult Function(FlexibleMode mode)? smallScaleBody,
    TResult Function(FlexibleMode mode)? medium,
    TResult Function(FlexibleMode mode)? large,
    required TResult orElse(),
  }) {
    if (large != null) {
      return large(mode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FlexibleOptionExtraSmall value) extraSmall,
    required TResult Function(FlexibleOptionSmallFixBody value) smallFixBody,
    required TResult Function(FlexibleOptionSmallScaleBody value)
        smallScaleBody,
    required TResult Function(FlexibleOptionMedium value) medium,
    required TResult Function(FlexibleOptionLarge value) large,
  }) {
    return large(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
  }) {
    return large?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FlexibleOptionExtraSmall value)? extraSmall,
    TResult Function(FlexibleOptionSmallFixBody value)? smallFixBody,
    TResult Function(FlexibleOptionSmallScaleBody value)? smallScaleBody,
    TResult Function(FlexibleOptionMedium value)? medium,
    TResult Function(FlexibleOptionLarge value)? large,
    required TResult orElse(),
  }) {
    if (large != null) {
      return large(this);
    }
    return orElse();
  }
}

abstract class FlexibleOptionLarge implements FlexibleOption {
  const factory FlexibleOptionLarge({required FlexibleMode mode}) =
      _$FlexibleOptionLarge;

  @override
  FlexibleMode get mode;
  @override
  @JsonKey(ignore: true)
  $FlexibleOptionLargeCopyWith<FlexibleOptionLarge> get copyWith =>
      throw _privateConstructorUsedError;
}
